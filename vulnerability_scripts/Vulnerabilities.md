## Input Validation Vulnerabilities

### 1. Conversation ID Validation Bypass (HIGH SEVERITY)
**Attack Script:** `input_validation_attack.py`

#### Description
The `/api/conversations` endpoint accepts any string as a conversation ID without validation. While parameterized queries prevent SQL injection execution, malicious strings are stored in the database causing data pollution and potential application logic bypasses.

#### What Attackers CAN Do:
- Store arbitrary strings (SQL syntax, Unicode, null bytes, extremely long strings)
- Pollute database with garbage IDs
- Cause application confusion when retrieving conversations
- Potential DoS through extremely long IDs (10,000+ characters)
- Break business logic with special characters

#### What Attackers CANNOT Do:
- Execute SQL code (parameterized queries prevent this)
- Access other users' data directly

#### Examples
```javascript
// server/routes/conversations.js - No ID validation
router.post('/', authenticateToken, async (req, res) => {
  const conversationId = conversation_entries[0].id;
  // Accepts: "'; DROP TABLE--", "ðŸ”’ä¼šè©±", "\x00\x00", "A" * 10000
  await run(
    `INSERT INTO conversations (id, ...) VALUES (?, ...)`,
    [entry.id, ...] // Any string stored as-is
  );
});
```

#### Impact
- Database pollution with malformed IDs
- Application crashes when processing special characters
- DoS through memory exhaustion (huge IDs)
- Business logic bypasses
- Difficult data cleanup and migration

---

### 2. Message Content Validation Bypass (HIGH SEVERITY)
**Attack Script:** `message_validation_attack.py`

#### Description
Multiple validation issues in the message endpoint allow attackers to send malicious data:

1. **No Size Limits:** `encrypted_msg_content` can be gigabytes in size
2. **Invalid Key Numbers:** `content_key_number` accepts negative, zero, or extremely large values
3. **No Type Validation:** Accepts strings, booleans, nulls where integers expected
4. **Special Characters:** Null bytes, control characters, SQL injection strings accepted

#### Examples
```javascript
// server/routes/messages.js - No validation
router.post('/', authenticateToken, async (req, res) => {
  const { conversation_id, content_key_number, encrypted_msg_content } = req.body;
  
  // Accepts:
  // - encrypted_msg_content: "A" * (5 * 1024 * 1024) // 5MB message
  // - content_key_number: -1, 0, 999999999
  // - content_key_number: "not a number", true, null
  
  await run(
    `INSERT INTO messages (...) VALUES (?, ?, ?, ...)`,
    [conversation_id, content_key_number, encrypted_msg_content, ...]
  );
});
```

#### Impact
- **DoS via Memory Exhaustion:** Gigabyte messages crash server
- **Integer Overflow:** Huge key numbers cause database issues
- **Type Confusion:** String/boolean as integers break logic
- **Application Errors:** Null bytes cause parsing failures
- **Storage Exhaustion:** Attacker fills disk with huge messages

---

### 3. Registration Field Validation Bypass (MEDIUM SEVERITY)
**Attack Script:** `registration_validation_attack.py`

#### Description
The registration endpoint has severe validation gaps in cryptographic fields:

1. **No Format Validation:** `public_key`, `salt`, `encrypted_private_key` accept any string
2. **No Size Limits:** Can register with multi-megabyte "keys"
3. **No Cryptographic Validation:** Invalid base64, wrong lengths accepted
4. **Weak Password Policy:** No complexity requirements

#### Examples
```javascript
// server/routes/auth.js - Minimal validation
router.post('/register', async (req, res) => {
  const { username, password, public_key, salt, encrypted_private_key } = req.body;
  
  // Only validates username exists and format
  // Accepts:
  // - public_key: "A" * (1024 * 1024) // 1MB "key"
  // - salt: "'; DROP TABLE users; --"
  // - encrypted_private_key: "ðŸ”‘" * 10000
  // - password: "abc" // Weak passwords accepted
  
  await run(
    `INSERT INTO users (...) VALUES (?, ?, ?, ?, ?, ?)`,
    [username, password_hash, public_key, salt, encrypted_private_key, ...]
  );
});
```

#### Impact
- **Storage Exhaustion:** Register thousands of users with GB keys
- **Cryptographic Failures:** Invalid keys break encryption
- **Weak Accounts:** Simple passwords enable brute force
- **Database Bloat:** Huge crypto fields slow queries
- **Application Confusion:** Invalid base64 causes parsing errors

---

### 4. Query Parameter Injection (MEDIUM SEVERITY)
**Attack Script:** `query_parameter_attack.py`

#### Description
The message retrieval endpoint has no bounds checking on `limit` and `offset` parameters:

1. **Unlimited Limit:** Can request billions of messages
2. **Negative Values:** Negative limit/offset accepted
3. **Integer Overflow:** 2^63 values cause issues
4. **Type Confusion:** Strings converted via parseInt without validation

#### Examples
```javascript
// server/routes/messages.js - Weak validation
router.get('/:conversationId', authenticateToken, async (req, res) => {
  const { limit = 50, offset = 0 } = req.query;
  
  // Accepts:
  // - limit: 999999999, -1, "not a number"
  // - offset: 2147483647, -1000, "50; DROP TABLE"
  
  const messages = await all(
    `SELECT ... LIMIT ? OFFSET ?`,
    [parseInt(limit, 10), parseInt(offset, 10)] // No bounds checking!
  );
});
```

#### Impact
- **DoS:** Request billion messages, exhaust memory
- **Performance Degradation:** Huge queries slow entire database
- **Integer Overflow:** Negative limits cause SQL errors
- **Bypass Pagination:** Attacker dumps entire database

---

### 5. Conversation Key Number Manipulation (MEDIUM SEVERITY)

#### Description
When adding participants or rotating keys, `content_key_number` validation is insufficient:
- Accepts extremely large numbers (> 999,999,999)
- No maximum limit enforcement
- Can skip key numbers (increment by 1000)

#### Impact
- Business logic bypass
- Key rotation confusion
- Integer overflow in key tracking

---

## Comprehensive Remediation

### Immediate Actions (Critical)
1. **Implement Input Validation Schema**
   ```javascript
   import Joi from 'joi';
   
   const conversationSchema = Joi.object({
     conversation_entries: Joi.array().items(
       Joi.object({
         id: Joi.string().alphanum().min(8).max(64).required(),
         username: Joi.string().required(),
         encrypted_content_key: Joi.string().base64().max(4096).required(),
         content_key_number: Joi.number().integer().positive().max(1000000).required()
       })
     ).min(1).required()
   });
   ```

2. **Add Field Size Limits**
   - `conversation_id`: 8-64 alphanumeric characters
   - `encrypted_msg_content`: Max 100KB per message
   - `public_key`: Max 4KB
   - `salt`: Max 256 bytes
   - `encrypted_private_key`: Max 16KB

3. **Enforce Type Validation**
   ```javascript
   // Before parseInt, validate it's actually a number string
   if (!/^\d+$/.test(limit)) {
     return res.status(400).json({ error: 'Invalid limit format' });
   }
   const limitNum = parseInt(limit, 10);
   if (limitNum < 1 || limitNum > 100) {
     return res.status(400).json({ error: 'Limit must be 1-100' });
   }
   ```

### High Priority
4. **Add Bounds Checking on Query Parameters**
   - `limit`: 1-100 range
   - `offset`: 0-1,000,000 range

5. **Validate Cryptographic Field Formats**
   - Verify base64 encoding
   - Check expected key lengths
   - Validate salt entropy

6. **Implement Password Complexity**
   - Minimum 8 characters
   - Require uppercase, lowercase, number
   - Check against common password lists

### Medium Priority
7. **Add Request Size Limits**
   - Set `express.json({ limit: '1mb' })` to prevent huge payloads

8. **Sanitize Special Characters**
   - Strip null bytes: `str.replace(/\x00/g, '')`
   - Reject control characters in IDs

9. **Add Monitoring**
   - Alert on oversized requests
   - Log validation failures
   - Track unusual patterns

---

Username Enumeration:
Attackers can check what usernames exist in the system via the /api/auth/check-username endpoint

possibly implement a freind request system.

---

Rate Limiting:
#### Issues
1. **IP-based only:** Easy to bypass using proxies or VPNs
2. **No account-level limiting:** Same account can be attacked from multiple IPs
3. **Too permissive:** 100 API requests per 15 minutes is high for most users
4. **No exponential backoff:** Failed attempts don't increase lockout time
5. **Missing endpoints:** Message sending, contact addition not rate limited

#### Impact
- Brute force attacks on authentication
- Account lockout DoS attacks
- API abuse and resource exhaustion
- Spam message flooding
- Distributed attacks bypass IP-based limits

#### Remediation
- Implement account-level rate limiting
- Add progressive delays after failed attempts
- Rate limit all sensitive endpoints (messages, conversations, contacts)
- Use CAPTCHA after repeated failures
- Implement distributed rate limiting (Redis)
- Add fingerprinting techniques beyond IP
