#!/usr/bin/env python3
"""
SecureDove Input Validation Attack Script
Tests input validation vulnerabilities, specifically for conversation IDs and other fields.
Demonstrates that non-conventional conversation IDs and malformed data can be stored.
"""

import requests
import sys
import time
import json
from typing import Dict, Optional, List, Tuple

class InputValidationTester:
    def __init__(self, base_url: str = "http://localhost:8000"):
        self.base_url = base_url.rstrip('/')
        self.api_url = f"{self.base_url}/api"
        self.session = requests.Session()
        self.token = None
        self.username = None
        
    def register_user(self, username: str, password: str, display_name: str = None, public_key: str = "dummy_public_key") -> bool:
        """Register a new user for testing"""
        try:
            payload = {
                "username": username,
                "password": password,
                "public_key": public_key,
                "salt": "dummy_salt_for_testing_purposes",
                "encrypted_private_key": "dummy_encrypted_private_key_for_testing"
            }
            
            response = self.session.post(
                f"{self.api_url}/auth/register",
                json=payload,
                timeout=5
            )
            
            if response.status_code in [200, 201]:
                print(f"[+] Successfully registered user: {username}")
                return True
            elif response.status_code == 409:
                print(f"[*] User {username} already exists")
                return True
            else:
                print(f"[-] Registration failed: {response.status_code} - {response.text}")
                return False
                
        except requests.RequestException as e:
            print(f"[-] Registration error: {e}")
            return False
    
    def login(self, username: str, password: str) -> bool:
        """Login and get authentication token"""
        try:
            response = self.session.post(
                f"{self.api_url}/auth/login",
                json={
                    "username": username,
                    "password": password
                },
                timeout=5
            )
            
            if response.status_code == 200:
                data = response.json()
                self.token = data.get('token')
                self.username = username
                print(f"[+] Successfully logged in as: {username}")
                print(f"[+] Token obtained: {self.token[:20]}...")
                return True
            else:
                print(f"[-] Login failed: {response.status_code} - {response.text}")
                return False
                
        except requests.RequestException as e:
            print(f"[-] Login error: {e}")
            return False
    
    def get_headers(self) -> Dict[str, str]:
        """Get authorization headers"""
        if not self.token:
            raise ValueError("Not authenticated. Please login first.")
        return {
            "Authorization": f"Bearer {self.token}",
            "Content-Type": "application/json"
        }
    
    def create_conversation_with_invalid_id(self, conversation_id: str, description: str) -> Tuple[bool, str]:
        """
        Attempt to create a conversation with a non-conventional ID
        Returns (success, response_message)
        """
        print(f"\n[*] Testing: {description}")
        print(f"[*] Conversation ID: '{conversation_id}'")
        
        try:
            payload = {
                "conversation_entries": [
                    {
                        "id": conversation_id,
                        "username": self.username,
                        "encrypted_content_key": "test_encrypted_key_data",
                        "content_key_number": 1
                    }
                ]
            }
            
            response = self.session.post(
                f"{self.api_url}/conversations",
                json=payload,
                headers=self.get_headers(),
                timeout=5
            )
            
            if response.status_code in [200, 201]:
                print(f"[!] VULNERABILITY: Successfully created conversation with invalid ID!")
                print(f"[!] Response: {response.json()}")
                return True, "Success - Vulnerability confirmed"
            else:
                print(f"[-] Request rejected: {response.status_code}")
                print(f"[-] Response: {response.text}")
                return False, f"Rejected with {response.status_code}"
                
        except requests.RequestException as e:
            print(f"[-] Request error: {e}")
            return False, str(e)
    
    def test_message_validation(self, conversation_id: str) -> Tuple[bool, str]:
        """Test message content validation vulnerabilities"""
        print(f"\n[*] Testing message validation for conversation: {conversation_id}")
        
        test_cases = [
            ("Extremely long message", "A" * 1000000),  # 1MB message
            ("Special characters", "'; DROP TABLE messages; --"),
            ("SQL injection attempt", "1' OR '1'='1"),
            ("Script injection", "<script>alert('XSS')</script>"),
            ("Null bytes", "Test\x00Message"),
            ("Unicode overflow", "ðŸš€" * 10000),
        ]
        
        results = []
        for test_name, content in test_cases:
            try:
                payload = {
                    "conversation_id": conversation_id,
                    "content_key_number": 1,
                    "encrypted_msg_content": content
                }
                
                response = self.session.post(
                    f"{self.api_url}/messages",
                    json=payload,
                    headers=self.get_headers(),
                    timeout=10
                )
                
                if response.status_code in [200, 201]:
                    print(f"[!] {test_name}: ACCEPTED (Vulnerability)")
                    results.append((test_name, True))
                else:
                    print(f"[-] {test_name}: Rejected ({response.status_code})")
                    results.append((test_name, False))
                    
            except Exception as e:
                print(f"[-] {test_name}: Error - {e}")
                results.append((test_name, False))
        
        vulnerabilities_found = sum(1 for _, success in results if success)
        return vulnerabilities_found > 0, f"{vulnerabilities_found}/{len(test_cases)} validation bypasses"
    
    def test_conversation_id_validation(self) -> List[Dict]:
        """Test various invalid conversation ID formats"""
        print("\n" + "="*70)
        print("TESTING CONVERSATION ID VALIDATION VULNERABILITIES")
        print("="*70)
        
        test_cases = [
            # SQL Injection attempts
            ("SQL Injection - DROP TABLE", "1'; DROP TABLE conversations; --"),
            ("SQL Injection - OR clause", "1' OR '1'='1"),
            ("SQL Injection - UNION", "1' UNION SELECT * FROM users --"),
            
            # Special characters and encoding
            ("Unicode characters", "ä¼šè©±_ðŸ”’_test"),
            ("Null bytes", "conv\x00id"),
            ("Newlines", "conv\nid\ntest"),
            ("Tabs", "conv\tid\ttest"),
            
            # Path traversal attempts
            ("Path traversal", "../../../etc/passwd"),
            ("Backslash path", "..\\..\\windows\\system32"),
            
            # Extremely long strings
            ("Very long ID", "A" * 10000),
            
            # Special formatting
            ("JSON injection", '{"injected": "data"}'),
            ("XML injection", "<conversation>test</conversation>"),
            ("Script tag", "<script>alert('xss')</script>"),
            
            # Whitespace variations
            ("Leading whitespace", "   conversation_id"),
            ("Trailing whitespace", "conversation_id   "),
            ("Only whitespace", "     "),
            
            # Empty and null
            ("Empty string", ""),
            ("Single quote", "'"),
            ("Double quote", '"'),
            
            # Format string attacks
            ("Format string", "%s%s%s%s%s"),
            ("Printf attack", "%x%x%x%x"),
            
            # Control characters
            ("Control characters", "\r\n\t\b"),
            
            # Boolean confusion
            ("Boolean true", "true"),
            ("Boolean false", "false"),
            ("Null string", "null"),
            ("Undefined string", "undefined"),
        ]
        
        results = []
        for description, conversation_id in test_cases:
            success, message = self.create_conversation_with_invalid_id(conversation_id, description)
            results.append({
                "test": description,
                "conversation_id": conversation_id,
                "vulnerable": success,
                "message": message
            })
            time.sleep(0.5)  # Rate limiting delay
        
        return results
    
    def test_field_validation(self) -> List[Dict]:
        """Test validation of other fields in conversation creation"""
        print("\n" + "="*70)
        print("TESTING OTHER FIELD VALIDATION VULNERABILITIES")
        print("="*70)
        
        test_cases = [
            {
                "name": "Missing required fields",
                "payload": {"conversation_entries": [{"id": "test_missing"}]},
                "should_fail": True
            },
            {
                "name": "Invalid content_key_number (negative)",
                "payload": {
                    "conversation_entries": [{
                        "id": "test_negative_key",
                        "username": self.username,
                        "encrypted_content_key": "test_key",
                        "content_key_number": -1
                    }]
                },
                "should_fail": True
            },
            {
                "name": "Invalid content_key_number (string)",
                "payload": {
                    "conversation_entries": [{
                        "id": "test_string_key",
                        "username": self.username,
                        "encrypted_content_key": "test_key",
                        "content_key_number": "not_a_number"
                    }]
                },
                "should_fail": True
            },
            {
                "name": "Extremely long encrypted_content_key",
                "payload": {
                    "conversation_entries": [{
                        "id": "test_long_key",
                        "username": self.username,
                        "encrypted_content_key": "A" * 1000000,
                        "content_key_number": 1
                    }]
                },
                "should_fail": True
            },
            {
                "name": "Empty conversation_entries array",
                "payload": {"conversation_entries": []},
                "should_fail": True
            },
            {
                "name": "Non-existent username in entries",
                "payload": {
                    "conversation_entries": [{
                        "id": "test_fake_user",
                        "username": "definitely_not_a_real_user_12345",
                        "encrypted_content_key": "test_key",
                        "content_key_number": 1
                    }]
                },
                "should_fail": True
            },
        ]
        
        results = []
        for test_case in test_cases:
            print(f"\n[*] Testing: {test_case['name']}")
            
            try:
                response = self.session.post(
                    f"{self.api_url}/conversations",
                    json=test_case['payload'],
                    headers=self.get_headers(),
                    timeout=5
                )
                
                success = response.status_code in [200, 201]
                expected_to_fail = test_case['should_fail']
                
                if success and expected_to_fail:
                    print(f"[!] VULNERABILITY: Request should have failed but succeeded!")
                    vulnerable = True
                elif not success and expected_to_fail:
                    print(f"[+] Correctly rejected (Status: {response.status_code})")
                    vulnerable = False
                else:
                    print(f"[?] Unexpected result (Status: {response.status_code})")
                    vulnerable = False
                
                results.append({
                    "test": test_case['name'],
                    "vulnerable": vulnerable,
                    "status_code": response.status_code,
                    "response": response.text[:200]
                })
                
            except Exception as e:
                print(f"[-] Error: {e}")
                results.append({
                    "test": test_case['name'],
                    "vulnerable": False,
                    "error": str(e)
                })
            
            time.sleep(0.5)
        
        return results
    
    def generate_report(self, conv_results: List[Dict], field_results: List[Dict]):
        """Generate a comprehensive vulnerability report"""
        print("\n" + "="*70)
        print("VULNERABILITY ASSESSMENT REPORT")
        print("="*70)
        
        # Conversation ID vulnerabilities
        conv_vulnerabilities = [r for r in conv_results if r['vulnerable']]
        print(f"\n[*] Conversation ID Validation Results:")
        print(f"    Total tests: {len(conv_results)}")
        print(f"    Vulnerabilities found: {len(conv_vulnerabilities)}")
        
        if conv_vulnerabilities:
            print(f"\n[!] VULNERABLE CONVERSATION IDs:")
            for vuln in conv_vulnerabilities:
                print(f"    - {vuln['test']}")
                print(f"      ID used: '{vuln['conversation_id']}'")
        
        # Field validation vulnerabilities
        field_vulnerabilities = [r for r in field_results if r['vulnerable']]
        print(f"\n[*] Field Validation Results:")
        print(f"    Total tests: {len(field_results)}")
        print(f"    Vulnerabilities found: {len(field_vulnerabilities)}")
        
        if field_vulnerabilities:
            print(f"\n[!] VULNERABLE FIELDS:")
            for vuln in field_vulnerabilities:
                print(f"    - {vuln['test']}")
        
        # Summary
        total_vulnerabilities = len(conv_vulnerabilities) + len(field_vulnerabilities)
        print(f"\n{'='*70}")
        print(f"TOTAL VULNERABILITIES FOUND: {total_vulnerabilities}")
        print(f"{'='*70}")
        
        # Recommendations
        print("\n[*] RECOMMENDATIONS:")
        if conv_vulnerabilities:
            print("    1. Implement strict conversation ID validation:")
            print("       - Use UUID format or enforce alphanumeric patterns")
            print("       - Reject special characters and SQL syntax")
            print("       - Set maximum length limits")
        if field_vulnerabilities:
            print("    2. Add comprehensive input validation:")
            print("       - Validate all field types and formats")
            print("       - Enforce maximum field lengths")
            print("       - Use schema validation libraries (Joi, Yup)")
        print("    3. Implement input sanitization before database operations")
        print("    4. Add request payload size limits")
        print("    5. Use parameterized queries (already in use, good!)")
        
        # Save report to file
        timestamp = time.strftime("%Y%m%d_%H%M%S")
        report_file = f"input_validation_report_{timestamp}.json"
        
        report_data = {
            "timestamp": timestamp,
            "target": self.api_url,
            "conversation_id_tests": conv_results,
            "field_validation_tests": field_results,
            "summary": {
                "total_tests": len(conv_results) + len(field_results),
                "total_vulnerabilities": total_vulnerabilities,
                "conversation_id_vulnerabilities": len(conv_vulnerabilities),
                "field_vulnerabilities": len(field_vulnerabilities)
            }
        }
        
        try:
            with open(report_file, 'w') as f:
                json.dump(report_data, f, indent=2)
            print(f"\n[+] Detailed report saved to: {report_file}")
        except Exception as e:
            print(f"\n[-] Could not save report: {e}")

def main():
    # Default configuration - hardcoded for easy testing
    base_url = "http://localhost:8000"
    username = "testuser"
    password = "testpass123"
    display_name = "Test User"
    
    # Allow overriding defaults via command line
    if len(sys.argv) > 1:
        base_url = sys.argv[1]
    if len(sys.argv) > 2:
        username = sys.argv[2]
    if len(sys.argv) > 3:
        password = sys.argv[3]
    
    print("="*70)
    print("SecureDove Input Validation Attack Script")
    print("="*70)
    print(f"Target: {base_url}")
    print(f"Username: {username}")
    print(f"Password: {'*' * len(password)}")
    print("="*70)
    print("\n[*] Note: Using hardcoded defaults for localhost:8000")
    print("[*] Override with: python input_validation_attack.py <url> <user> <pass>")
    print("="*70)
    
    tester = InputValidationTester(base_url)
    
    # Register and login
    print("\n[*] Setting up test account...")
    if not tester.register_user(username, password, display_name):
        print("[*] Registration failed or user exists. Attempting login...")
    
    if not tester.login(username, password):
        print("\n[-] Authentication failed!")
        print("[*] Attempting to create a new test user...")
        
        # Try with a timestamped username if the default fails
        alt_username = f"validator_{int(time.time())}"
        alt_password = "TestPassword123!"
        
        print(f"[*] Trying alternative credentials: {alt_username}")
        if tester.register_user(alt_username, alt_password, f"Validator {int(time.time())}"):
            if tester.login(alt_username, alt_password):
                print(f"[+] Successfully authenticated with {alt_username}")
            else:
                print("[-] Could not authenticate. Please ensure the server is running.")
                print("[-] Server should be at: http://localhost:8000")
                sys.exit(1)
        else:
            print("[-] Could not create test user. Exiting.")
            print("[-] Please ensure:")
            print("    1. Server is running on http://localhost:8000")
            print("    2. Database is initialized")
            print("    3. API endpoints are accessible")
            sys.exit(1)
    
    # Run tests
    time.sleep(1)
    
    print("\n[*] Starting vulnerability tests...")
    conv_results = tester.test_conversation_id_validation()
    
    time.sleep(2)
    field_results = tester.test_field_validation()
    
    # Generate report
    tester.generate_report(conv_results, field_results)
    
    print("\n[*] Testing complete!")

if __name__ == "__main__":
    main()
