#!/usr/bin/env python3
"""
SecureDove Input Validation Attack Script
Tests input validation vulnerabilities in message content, conversation IDs, encrypted keys, and JSON parsing
"""

import requests
import sys
import json
import time
from typing import Dict, Any, Optional, Tuple

class InputValidationAttacker:
    def __init__(self, base_url: str = "http://localhost:8000"):
        self.base_url = base_url.rstrip('/')
        self.api_url = f"{self.base_url}/api"
        self.session = requests.Session()
        self.auth_token: Optional[str] = None

    def authenticate(self, username: str = "testuser", password: str = "testpass123") -> bool:
        """Authenticate and get JWT token"""
        endpoint = f"{self.api_url}/auth/login"
        payload = {"username": username, "password": password}

        try:
            response = self.session.post(endpoint, json=payload, timeout=10)
            if response.status_code == 200:
                data = response.json()
                self.auth_token = data.get('token')
                self.session.headers.update({'Authorization': f'Bearer {self.auth_token}'})
                print(f"[+] Authenticated as {username}")
                return True
            else:
                print(f"[-] Authentication failed: {response.status_code} - {response.text}")
                return False
        except requests.RequestException as e:
            print(f"[-] Authentication error: {str(e)}")
            return False

    def register_test_user(self) -> bool:
        """Register a test user if needed"""
        endpoint = f"{self.api_url}/auth/register"
        payload = {
            "username": "testuser",
            "password": "testpass123",
            "public_key": "dummy_public_key",
            "salt": "dummy_salt",
            "encrypted_private_key": "dummy_encrypted_private_key"
        }

        try:
            response = self.session.post(endpoint, json=payload, timeout=10)
            if response.status_code == 201:
                print("[+] Test user registered")
                return True
            elif response.status_code == 409:
                print("[+] Test user already exists")
                return True
            else:
                print(f"[-] Registration failed: {response.status_code} - {response.text}")
                return False
        except requests.RequestException as e:
            print(f"[-] Registration error: {str(e)}")
            return False

    def test_message_content_validation(self) -> Dict[str, Any]:
        """Test message content validation vulnerabilities"""
        results = {}
        print("\n[*] Testing Message Content Validation (/api/messages)")
        print("[*] Vulnerabilities: No length limits, no content validation")

        # Test 1: Huge message content (DoS via memory exhaustion)
        print("\n[+] Test 1: Huge message content (10MB)")
        huge_content = "A" * (10 * 1024 * 1024)  # 10MB string
        payload = {
            "conversation_id": "test_conv_123",
            "content_key_number": 1,
            "encrypted_msg_content": huge_content
        }

        start_time = time.time()
        try:
            response = self.session.post(f"{self.api_url}/messages", json=payload, timeout=30)
            end_time = time.time()
            results['huge_content'] = {
                'status_code': response.status_code,
                'response_time': end_time - start_time,
                'response_size': len(response.text),
                'success': response.status_code == 201
            }
            print(f"    Status: {response.status_code}, Time: {end_time - start_time:.2f}s")
            if response.status_code == 201:
                print("    ⚠️  SUCCESS: Huge message accepted - potential DoS vulnerability!")
            elif response.status_code == 413:  # Payload too large
                print("    ✅ BLOCKED: Payload too large")
            else:
                print(f"    ❌ FAILED: {response.status_code} - {response.text[:100]}")
        except requests.RequestException as e:
            end_time = time.time()
            results['huge_content'] = {
                'status_code': -1,
                'response_time': end_time - start_time,
                'error': str(e),
                'success': False
            }
            print(f"    ❌ ERROR: {e}")

        # Test 2: Null bytes and special characters
        print("\n[+] Test 2: Malformed content with null bytes")
        malicious_content = "normal_content\x00\x01\x02" + "A" * 1000
        payload = {
            "conversation_id": "test_conv_123",
            "content_key_number": 1,
            "encrypted_msg_content": malicious_content
        }

        try:
            response = self.session.post(f"{self.api_url}/messages", json=payload, timeout=10)
            results['null_bytes'] = {
                'status_code': response.status_code,
                'response_length': len(response.text),
                'success': response.status_code == 201
            }
            print(f"    Status: {response.status_code}")
            if response.status_code == 201:
                print("    ⚠️  SUCCESS: Null bytes accepted - potential parsing issues!")
        except requests.RequestException as e:
            results['null_bytes'] = {'error': str(e)}
            print(f"    ❌ ERROR: {e}")

        # Test 3: Extremely long conversation_id
        print("\n[+] Test 3: Extremely long conversation ID")
        long_id = "A" * 10000  # 10KB ID
        payload = {
            "conversation_id": long_id,
            "content_key_number": 1,
            "encrypted_msg_content": "test_content"
        }

        try:
            response = self.session.post(f"{self.api_url}/messages", json=payload, timeout=10)
            results['long_id'] = {
                'status_code': response.status_code,
                'success': response.status_code == 201
            }
            print(f"    Status: {response.status_code}")
            if response.status_code == 201:
                print("    ⚠️  SUCCESS: Long ID accepted - potential DoS or DB issues!")
        except requests.RequestException as e:
            results['long_id'] = {'error': str(e)}
            print(f"    ❌ ERROR: {e}")

        return results

    def test_conversation_validation(self) -> Dict[str, Any]:
        """Test conversation creation validation vulnerabilities"""
        results = {}
        print("\n[*] Testing Conversation Validation (/api/conversations)")
        print("[*] Vulnerabilities: No validation of conversation IDs, keys, or entries")

        # Test 1: Malformed conversation entries
        print("\n[+] Test 1: Malformed conversation entries")
        payload = {
            "conversation_entries": [
                {
                    "id": "test_conv_malformed",
                    "username": "testuser",
                    "encrypted_content_key": "dummy_key",
                    # Missing content_key_number
                },
                {
                    "id": "test_conv_malformed",
                    "username": "nonexistent_user",  # User doesn't exist
                    "encrypted_content_key": "dummy_key",
                    "content_key_number": 1
                }
            ]
        }

        try:
            response = self.session.post(f"{self.api_url}/conversations", json=payload, timeout=10)
            results['malformed_entries'] = {
                'status_code': response.status_code,
                'response': response.text[:200],
                'success': response.status_code in [200, 201]
            }
            print(f"    Status: {response.status_code}")
            if response.status_code in [200, 201]:
                print("    ⚠️  SUCCESS: Malformed entries accepted!")
            else:
                print(f"    Response: {response.text[:100]}")
        except requests.RequestException as e:
            results['malformed_entries'] = {'error': str(e)}
            print(f"    ❌ ERROR: {e}")

        # Test 2: Huge encrypted keys
        print("\n[+] Test 2: Huge encrypted content keys")
        huge_key = "B" * (1024 * 1024)  # 1MB key
        payload = {
            "conversation_entries": [
                {
                    "id": "test_conv_huge_key",
                    "username": "testuser",
                    "encrypted_content_key": huge_key,
                    "content_key_number": 1
                }
            ]
        }

        try:
            response = self.session.post(f"{self.api_url}/conversations", json=payload, timeout=30)
            results['huge_keys'] = {
                'status_code': response.status_code,
                'response_time': response.elapsed.total_seconds(),
                'success': response.status_code in [200, 201]
            }
            print(f"    Status: {response.status_code}, Time: {response.elapsed.total_seconds():.2f}s")
            if response.status_code in [200, 201]:
                print("    ⚠️  SUCCESS: Huge keys accepted - potential DoS!")
        except requests.RequestException as e:
            results['huge_keys'] = {'error': str(e)}
            print(f"    ❌ ERROR: {e}")

        # Test 3: Invalid data types
        print("\n[+] Test 3: Invalid data types (numbers as strings)")
        payload = {
            "conversation_entries": [
                {
                    "id": 12345,  # Number instead of string
                    "username": "testuser",
                    "encrypted_content_key": "dummy_key",
                    "content_key_number": "1"  # String instead of number
                }
            ]
        }

        try:
            response = self.session.post(f"{self.api_url}/conversations", json=payload, timeout=10)
            results['invalid_types'] = {
                'status_code': response.status_code,
                'success': response.status_code in [200, 201]
            }
            print(f"    Status: {response.status_code}")
            if response.status_code in [200, 201]:
                print("    ⚠️  SUCCESS: Invalid types accepted - type confusion possible!")
        except requests.RequestException as e:
            results['invalid_types'] = {'error': str(e)}
            print(f"    ❌ ERROR: {e}")

        return results

    def test_json_parsing_validation(self) -> Dict[str, Any]:
        """Test JSON parsing vulnerabilities"""
        results = {}
        print("\n[*] Testing JSON Parsing Validation")
        print("[*] Vulnerabilities: No schema validation, potential for malformed JSON")

        # Test 1: Malformed JSON (truncated)
        print("\n[+] Test 1: Malformed JSON payload")
        malformed_json = '{"conversation_id": "test", "content_key_number": 1, "encrypted_msg_content": "test"'  # Missing closing brace

        try:
            response = self.session.post(
                f"{self.api_url}/messages",
                data=malformed_json,
                headers={'Content-Type': 'application/json'},
                timeout=10
            )
            results['malformed_json'] = {
                'status_code': response.status_code,
                'response': response.text[:200]
            }
            print(f"    Status: {response.status_code}")
            if 'json' in response.text.lower() or response.status_code == 400:
                print("    ✅ BLOCKED: JSON parsing error handled")
            else:
                print("    ⚠️  UNEXPECTED: Server accepted malformed JSON")
        except requests.RequestException as e:
            results['malformed_json'] = {'error': str(e)}
            print(f"    ❌ ERROR: {e}")

        # Test 2: Nested objects where primitives expected
        print("\n[+] Test 2: Nested objects in primitive fields")
        payload = {
            "conversation_id": {"nested": "object"},  # Object instead of string
            "content_key_number": {"value": 1},       # Object instead of number
            "encrypted_msg_content": "valid_content"
        }

        try:
            response = self.session.post(f"{self.api_url}/messages", json=payload, timeout=10)
            results['nested_objects'] = {
                'status_code': response.status_code,
                'success': response.status_code == 201
            }
            print(f"    Status: {response.status_code}")
            if response.status_code == 201:
                print("    ⚠️  SUCCESS: Nested objects accepted - type confusion!")
        except requests.RequestException as e:
            results['nested_objects'] = {'error': str(e)}
            print(f"    ❌ ERROR: {e}")

        return results

    def run_comprehensive_attack(self) -> Dict[str, Any]:
        """Run all input validation attacks"""
        print("=" * 80)
        print("SECUREDOBE INPUT VALIDATION VULNERABILITY ASSESSMENT")
        print("=" * 80)
        print("Testing input validation in messages, conversations, and JSON parsing")
        print()

        # Setup
        if not self.register_test_user():
            print("[-] Could not setup test user")
            return {}

        if not self.authenticate():
            print("[-] Could not authenticate")
            return {}

        all_results = {}

        # Run attacks
        message_results = self.test_message_content_validation()
        all_results.update(message_results)

        conversation_results = self.test_conversation_validation()
        all_results.update(conversation_results)

        json_results = self.test_json_parsing_validation()
        all_results.update(json_results)

        # Summary
        self.print_attack_summary(all_results)

        return all_results

    def print_attack_summary(self, results: Dict[str, Any]):
        """Print comprehensive attack summary"""
        print("\n" + "=" * 80)
        print("INPUT VALIDATION ATTACK SUMMARY")
        print("=" * 80)

        successful_attacks = []
        blocked_attacks = []
        errors = []

        for test_name, result in results.items():
            if result.get('success'):
                successful_attacks.append(test_name)
            elif result.get('status_code') in [400, 413]:
                blocked_attacks.append(test_name)
            elif 'error' in result:
                errors.append(test_name)

        print(f"Total tests performed: {len(results)}")
        print(f"Successful attacks: {len(successful_attacks)}")
        print(f"Properly blocked: {len(blocked_attacks)}")
        print(f"Errors: {len(errors)}")

        if successful_attacks:
            print("\n🚨 VULNERABILITIES FOUND!")
            print("The following attacks succeeded:")
            for attack in successful_attacks:
                print(f"  - {attack.replace('_', ' ').title()}")
        else:
            print("\n✅ No successful attacks - input validation appears adequate")

        print("\n" + "-" * 80)
        print("WHAT CAN BE ACHIEVED:")
        print("-" * 80)

        if 'huge_content' in successful_attacks:
            print("💥 DoS ATTACK: Large message content accepted")
            print("  • Memory exhaustion on server")
            print("  • Database bloat with large records")
            print("  • Potential service disruption")

        if 'null_bytes' in successful_attacks:
            print("🔧 PARSING ATTACK: Null bytes in content accepted")
            print("  • Potential buffer overflow in C extensions")
            print("  • Database corruption with binary data")
            print("  • Unexpected behavior in string processing")

        if 'long_id' in successful_attacks:
            print("📊 RESOURCE ATTACK: Long conversation IDs accepted")
            print("  • Database index performance degradation")
            print("  • UI rendering issues with long strings")
            print("  • Potential memory issues in client apps")

        if 'malformed_entries' in successful_attacks:
            print("🔀 LOGIC ATTACK: Malformed conversation entries accepted")
            print("  • Business logic bypass")
            print("  • Inconsistent conversation state")
            print("  • Potential privilege escalation")

        if 'huge_keys' in successful_attacks:
            print("💥 DoS ATTACK: Large encryption keys accepted")
            print("  • Memory exhaustion during key processing")
            print("  • Database storage exhaustion")
            print("  • Slow response times")

        if 'invalid_types' in successful_attacks:
            print("🎭 TYPE CONFUSION: Invalid data types accepted")
            print("  • Unexpected behavior in JavaScript")
            print("  • Potential runtime errors")
            print("  • Logic bypasses")

        if 'nested_objects' in successful_attacks:
            print("🔍 SCHEMA ATTACK: Nested objects in primitive fields")
            print("  • Type confusion vulnerabilities")
            print("  • Potential prototype pollution")
            print("  • Unexpected serialization behavior")

        print("\n" + "=" * 80)
        print("RECOMMENDATIONS")
        print("=" * 80)
        if successful_attacks:
            print("🚨 IMMEDIATE ACTION REQUIRED:")
            print("- Implement input validation middleware (Joi, Yup)")
            print("- Add length limits for all string fields")
            print("- Validate data types and formats")
            print("- Use JSON schema validation")
            print("- Implement request size limits")
            print("- Add database constraints")
        else:
            print("✅ Input validation appears robust")
            print("- Continue monitoring for new attack vectors")
            print("- Regular validation testing recommended")

def main():
    if len(sys.argv) > 1:
        base_url = sys.argv[1]
    else:
        base_url = "http://localhost:8000"

    print(f"[*] Targeting server: {base_url}")

    attacker = InputValidationAttacker(base_url)
    attacker.run_comprehensive_attack()

if __name__ == "__main__":
    main()